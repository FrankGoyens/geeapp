<!DOCTYPE html>
<html>
	<head>
	<style>
		#c{
			width: 1280px;
			height: 720px;
		}
	</style>
	</head>
	<body>
		<canvas width="1280" height="720" id="c"/>
		<script lang="text/javascript">
		"use strict";
		const vertex_shader_source = 
			`// an attribute will receive data from a buffer
			attribute vec4 position;
			
			uniform mat4 mvp_matrix;

			// all shaders have a main function
			void main() {

			  // gl_Position is a special variable a vertex shader 
			  // is responsible for setting
			  gl_Position = mvp_matrix * position;
			}`;
		
		const fragment_shader_source = 
			`// fragment shaders don't have a default precision so we need
			// to pick one. mediump, short for medium precision, is a good default.
			precision mediump float;

			void main() {
			  // gl_FragColor is a special variable a fragment shader
			  // is responsible for setting
			  gl_FragColor = vec4(1, 0, 0.5, 1); // return redish-purple 
			}`;
			
		const canvas = document.getElementById("c");
		const gl = canvas.getContext("webgl");
		if (!gl) {
			alert("No OpenGL!");
		}
		else{
			start_rendering_to_gl_context(canvas, gl);
		}
		
		function start_rendering_to_gl_context(canvas, gl){
			gl.clearColor(0, 1, 0, 1);
			gl.clear(gl.COLOR_BUFFER_BIT);
			
			const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertex_shader_source);
			const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragment_shader_source);
			const program = createProgram(gl, vertexShader, fragmentShader);
			
			gl.useProgram(program);
			
			const positionAttributeLocation = gl.getAttribLocation(program, "position");
			
			const positionBuffer = gl.createBuffer();
			
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			
			const positions = [
				500, 300, -200,
				500, 600, -200,
				700, 300, -200
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
			
			gl.enableVertexAttribArray(positionAttributeLocation);
			
			const size = 3;          // 2 components per iteration
			const type = gl.FLOAT;   // the data is 32bit floats
			const normalize = false; // use the data as is
			const stride = 0;        // 0 = move size * sizeof(type) each iteration
			const buffer_offset = 0; // start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, buffer_offset);
			
			// buffer mvp_matrix
			const mvp_matrix_buffer = gl.createBuffer();
			const mvp_matrix_position = gl.getUniformLocation(program, "mvp_matrix");
			
			const p_matrix = create_perspective_matrix(90.0, canvas.width/canvas.height, 0.1, 250);
			const v_matrix = create_lookat_matrix(
				[canvas.width/2, canvas.height/2, 1], 
				[canvas.width/2 + Math.sin(0), canvas.height/2, 1 - Math.cos(0)], 
				[0, 1, 0]);
			
			const vp_matrix = multiply(v_matrix, p_matrix);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, vp_matrix);
			
			const primitiveType = gl.TRIANGLES;
			const draw_offset = 0;
			const count = 3;
			gl.drawArrays(primitiveType, draw_offset, count);
		}
		
		function createShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);  
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				return shader;
			}

			console.log(gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}
		
		function createProgram(gl, vertexShader, fragmentShader) {
			const program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				return program;
			}

			console.log(gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}
		
		function create_perspective_matrix(fov, aspect, near, far){
			const tanHalfFov = Math.tan(fov / 2);
			
			return [
				1/(aspect * tanHalfFov), 0, 0, 0, 
				0, 1/tanHalfFov, 0, 0, 
				0, 0, -(far + near)/(far - near), -1, 
				0, 0, -(2 * far * near) / (far - near), 0
			];
		}
		
		function create_lookat_matrix(eye, center, up){			
			const f = normalize(minus(center, eye));
			const s = normalize(cross(f, up));
			const u = normalize(cross(s, f));
			
			return [
				s[0], u[0], -f[0], 0,
				s[1], u[1], -f[1], 0,
				s[2], u[2], -f[2], 0,
				-dot(s, eye), -dot(u, eye), dot(f, eye), 1
			];
		}
		
		function normalize(vec3){
			const m = magnitude(vec3);
			return [vec3[0] / m, vec3[1] / m, vec3[2] / m];
		}
		
		function magnitude(vec3){
			return Math.sqrt(vec3[0] * vec3[0] + vec3[1] * vec3[1] + vec3[2] * vec3[2]);
		}
		
		function dot(lhs_vec3, rhs_vec3){
			return lhs_vec3[0] * rhs_vec3[0] + lhs_vec3[1] * rhs_vec3[1] + lhs_vec3[2] * rhs_vec3[2];
		}
		
		function minus(lhs_vec3, rhs_vec3){
			return [lhs_vec3[0] - rhs_vec3[0], lhs_vec3[1] - rhs_vec3[1], lhs_vec3[2] - rhs_vec3[2]]
		}
		
		function cross(lhs_vec3, rhs_vec3){
			return [ 
				lhs_vec3[1] * rhs_vec3[2] - lhs_vec3[2] * rhs_vec3[1], 
				lhs_vec3[2] * rhs_vec3[0] - lhs_vec3[0] * rhs_vec3[2],
				lhs_vec3[0] * rhs_vec3[1] - lhs_vec3[1] * rhs_vec3[0]]
		}
		
		function multiply(lhs_mat4, rhs_mat4){
			return [
				dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 3))
			]
		}
		
		function multiply_4x4_4x1(mat, vec){
			return [
				dot4(row4(mat, 0), vec),
				dot4(row4(mat, 1), vec),
				dot4(row4(mat, 2), vec),
				dot4(row4(mat, 3), vec)
			]
		}
		
		function scalar_multiply(vec4, scalar){
			return [vec4[0]*scalar, vec4[1]*scalar, vec4[2]*scalar, vec4[3]*scalar]
		}
		
		function row4(mat, row_index){
			return row(mat, row_index, 4);
		}
		
		function row(mat, row_index, stride){
			const offset = stride * row_index;
			return [mat[offset], mat[offset + 1], mat[offset + 2], mat[offset + 3]];
		}
		
		function col4(mat, col_index){
			return col(mat, col_index, 4);
		}
		
		function col(mat, col_index, stride){
			return [mat[col_index], mat[col_index + stride], mat[col_index + stride * 2], mat[col_index + stride * 3]];
		}
		
		function dot4(lhs_vec4, rhs_vec4){
			return dot(lhs_vec4, rhs_vec4) + lhs_vec4[3] * rhs_vec4[3];
		}
		
		</script>
	</body>
</html>