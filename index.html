<!DOCTYPE html>
<html>
	<head>
	<style>
		#c{
			width: 1280px;
			height: 720px;
		}
	</style>
	</head>
	<body>
		<canvas width="1280" height="720" id="c"/>
		<script lang="text/javascript">
		"use strict";
		const vertex_shader_source = 
			`// an attribute will receive data from a buffer
			attribute vec4 position;
			
			uniform mat4 mvp_matrix;

			// all shaders have a main function
			void main() {

			  // gl_Position is a special variable a vertex shader 
			  // is responsible for setting
			  gl_Position = mvp_matrix * position;
			}`;
		
		const fragment_shader_source = 
			`// fragment shaders don't have a default precision so we need
			// to pick one. mediump, short for medium precision, is a good default.
			precision mediump float;

			void main() {
			  // gl_FragColor is a special variable a fragment shader
			  // is responsible for setting
			  gl_FragColor = vec4(1, 0, 0.5, 1); // return redish-purple 
			}`;
			
		const canvas = document.getElementById("c");
		const gl = canvas.getContext("webgl");
		if (!gl) {
			alert("No OpenGL!");
		}
		else{
			start_rendering_to_gl_context(canvas, gl);
		}
		
		function start_rendering_to_gl_context(canvas, gl){
			const NEAR = 0.1;
			const FAR = 1100;
			gl.clearColor(0, 1, 0, 1);
			gl.clear(gl.COLOR_BUFFER_BIT);
			
			const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertex_shader_source);
			const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragment_shader_source);
			const program = createProgram(gl, vertexShader, fragmentShader);
			
			gl.useProgram(program);
			
			const positionAttributeLocation = gl.getAttribLocation(program, "position");
			
			const positionBuffer = gl.createBuffer();
			
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			
			const positions = [
				-100, 50, -200,
				-100, 300, -200,
				300, 50, -200
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
			
			gl.enableVertexAttribArray(positionAttributeLocation);
			
			const size = 3;          // 2 components per iteration
			const type = gl.FLOAT;   // the data is 32bit floats
			const normalize = false; // use the data as is
			const stride = 0;        // 0 = move size * sizeof(type) each iteration
			const buffer_offset = 0; // start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, buffer_offset);
			
			// buffer mvp_matrix
			const mvp_matrix_buffer = gl.createBuffer();
			const mvp_matrix_position = gl.getUniformLocation(program, "mvp_matrix");
			
			const p_matrix = create_perspective_matrix(90.0, canvas.width/canvas.height, NEAR, FAR);
			const v_matrix = create_lookat_matrix(
				[0, 0, 1], 
				[Math.sin(0), 0, 1 - Math.cos(0)], 
				[0, 1, 0]);
			
			const vp_matrix = multiply(v_matrix, p_matrix);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, vp_matrix);
			
			const primitiveType = gl.TRIANGLES;
			const draw_offset = 0;
			const count = 3;
			gl.drawArrays(primitiveType, draw_offset, count);

			const grid_lines = create_bottom_grid_lines(0, 1000, 1/30);
			render_lines(gl, grid_lines, positionAttributeLocation, vp_matrix, mvp_matrix_position);
		}
		
		function createShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);  
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				return shader;
			}

			console.log(gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}
		
		function createProgram(gl, vertexShader, fragmentShader) {
			const program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				return program;
			}

			console.log(gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}
		
		function create_perspective_matrix(fov, aspect, near, far){
			const tanHalfFov = Math.tan(fov / 2);
			
			return [
				1/(aspect * tanHalfFov), 0, 0, 0, 
				0, 1/tanHalfFov, 0, 0, 
				0, 0, -(far + near)/(far - near), -1, 
				0, 0, -(2 * far * near) / (far - near), 0
			];
		}
		
		function create_lookat_matrix(eye, center, up){			
			const f = normalize(minus(center, eye));
			const s = normalize(cross(f, up));
			const u = normalize(cross(s, f));
			
			return [
				s[0], u[0], -f[0], 0,
				s[1], u[1], -f[1], 0,
				s[2], u[2], -f[2], 0,
				-dot(s, eye), -dot(u, eye), dot(f, eye), 1
			];
		}
		
		function create_translation_matrix(translation){
			return[
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				translation[0], translation[1], translation[2], 1
			];
		}
		
		function create_rotation_matrix_along_x(angle){
			const cos_angle = Math.cos(angle);
			const sin_angle = Math.sin(angle);
			return[
				1, 0, 0, 0,
				0, cos_angle, sin_angle, 0,
				0, -sin_angle, cos_angle, 0,
				0, 0, 0, 1
			];
		}
		
		function create_scale_matrix(scale_x, scale_y, scale_z){
			return [
				scale_x, 0, 0, 0,
				0, scale_y, 0, 0,
				0, 0, scale_z, 0,
				0, 0, 0, 1
			];
		}
		
		function normalize(vec3){
			const m = magnitude(vec3);
			return [vec3[0] / m, vec3[1] / m, vec3[2] / m];
		}
		
		function magnitude(vec3){
			return Math.sqrt(vec3[0] * vec3[0] + vec3[1] * vec3[1] + vec3[2] * vec3[2]);
		}
		
		function dot(lhs_vec3, rhs_vec3){
			return lhs_vec3[0] * rhs_vec3[0] + lhs_vec3[1] * rhs_vec3[1] + lhs_vec3[2] * rhs_vec3[2];
		}
		
		function minus(lhs_vec3, rhs_vec3){
			return [lhs_vec3[0] - rhs_vec3[0], lhs_vec3[1] - rhs_vec3[1], lhs_vec3[2] - rhs_vec3[2]]
		}
		
		function cross(lhs_vec3, rhs_vec3){
			return [ 
				lhs_vec3[1] * rhs_vec3[2] - lhs_vec3[2] * rhs_vec3[1], 
				lhs_vec3[2] * rhs_vec3[0] - lhs_vec3[0] * rhs_vec3[2],
				lhs_vec3[0] * rhs_vec3[1] - lhs_vec3[1] * rhs_vec3[0]]
		}
		
		function multiply(lhs_mat4, rhs_mat4){
			return [
				dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 3))
			]
		}
		
		function multiply_4x4_4x1(mat, vec){
			return [
				dot4(row4(mat, 0), vec),
				dot4(row4(mat, 1), vec),
				dot4(row4(mat, 2), vec),
				dot4(row4(mat, 3), vec)
			]
		}
		
		function scalar_multiply(vec4, scalar){
			return [vec4[0]*scalar, vec4[1]*scalar, vec4[2]*scalar, vec4[3]*scalar]
		}
		
		function row4(mat, row_index){
			return row(mat, row_index, 4);
		}
		
		function row(mat, row_index, stride){
			const offset = stride * row_index;
			return [mat[offset], mat[offset + 1], mat[offset + 2], mat[offset + 3]];
		}
		
		function col4(mat, col_index){
			return col(mat, col_index, 4);
		}
		
		function col(mat, col_index, stride){
			return [mat[col_index], mat[col_index + stride], mat[col_index + stride * 2], mat[col_index + stride * 3]];
		}
		
		function dot4(lhs_vec4, rhs_vec4){
			return dot(lhs_vec4, rhs_vec4) + lhs_vec4[3] * rhs_vec4[3];
		}
		
		function create_bottom_grid_lines(near, far, lines_per_unit){
			const grid_magnitude = far - near;
			const line_amount = Math.ceil(grid_magnitude * lines_per_unit); //amount for both horizontal and vertical
			const line_spacing = grid_magnitude / line_amount;
			let lines = [];
			for(let i=0; i<line_amount+1; ++i){
				const current_horizontal_pos = i * line_spacing;
				lines.push(0); //x1
				lines.push(current_horizontal_pos); //y1
				lines.push(grid_magnitude); //x2
				lines.push(current_horizontal_pos); //y2
			}
			for(let j=0; j<line_amount+1; ++j){
				const current_vertical_pos = j * line_spacing;
				lines.push(current_vertical_pos); //x1
				lines.push(0); //y1
				lines.push(current_vertical_pos); //x2
				lines.push(grid_magnitude); //y2
			}
			return lines;
		}
		
		// Shader program should already be set up
		function render_lines(gl, lines, positionAttributeLocation, vp_matrix, mvp_matrix_position){
			const linePositionBuffer = gl.createBuffer();
			
			gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
			
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);
			
			const size = 2;          // 2 components per iteration
			const type = gl.FLOAT;   // the data is 32bit floats
			const normalize = false; // use the data as is
			const stride = 0;        // 0 = move size * sizeof(type) each iteration
			const buffer_offset = 0; // start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, buffer_offset);
			
			const m_matrix = multiply_sequence([
				create_translation_matrix([0, 0, -180]),
				create_rotation_matrix_along_x(-Math.PI/2 - Math.PI/8),
				create_scale_matrix(5, 1, 1),
				create_translation_matrix([-500 * 5, -50, 0])
			]);
			
			const mvp_matrix = multiply(m_matrix, vp_matrix);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, mvp_matrix);
			
			const primitiveType = gl.LINES;
			const draw_offset = 0;
			gl.drawArrays(primitiveType, draw_offset, lines.length);
		}
		
		function multiply_sequence(sequence){
			let result = create_identity_matrix();
			for(let i=0; i<sequence.length; i++){
				result = multiply(result, sequence[i]);
			}
			return result;
		}
		
		function create_identity_matrix(){
			return [
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			]
		}
		
		</script>
	</body>
</html>