<!DOCTYPE html>
<html>
	<head>
	<style>
		#c{
			width: 1280px;
			height: 720px;
		}
	</style>
	<script src="gl-matrix-min.js"></script>
	</head>
	<body>
		<canvas width="1280" height="720" id="c"/>
		<script lang="text/javascript">
		"use strict";
		class Particle{
			constructor(position, force, mass, velocity){
				this.position = position;
				this.force = force;
				this.mass = mass;
				this.velocity = velocity;
			}
			
			update_position(delta_t){
				const acceleration = scalar_multiply(this.force, 1/this.mass);
				this.velocity = scalar_multiply(acceleration, delta_t);
				const new_position = integrate_midpoint(this.position, this.velocity, acceleration, delta_t);
				this.position = new_position;
			}
		}
		
		class Spring{
			constructor(first_particle, second_particle, spring_constant, dampening_constant, rest_length){
				this.first_particle = first_particle;
				this.second_particle = second_particle;
				this.spring_constant = spring_constant;
				this.dampening_constant = dampening_constant;
				this.rest_length = rest_length;
			}
			
			calculate_forces_on_particles(){
				const delta_vec = minus(this.first_particle.position, this.second_particle.position);
				const length = magnitude(delta_vec);
				const delta_velocity = minus(this.first_particle.velocity, this.second_particle.velocity);
				
				const force = scalar_multiply(scalar_multiply(delta_vec, 1/length), (this.spring_constant * (length - this.rest_length) + this.dampening_constant * (dot(delta_velocity, delta_vec) / length)));
				return {
					"force_first_particle": scalar_multiply(force, -1),
					"force_second_particle": force
				}
			}
		}
		
		class ParticleSystem{
			constructor(particles, springs){
				this.particles = particles;
				this.springs = springs;
			}
			
			update(delta_t){
				this.springs.forEach((spring)=>{
					const forces = spring.calculate_forces_on_particles();
					spring.first_particle.force = plus(spring.first_particle.force, forces.force_first_particle);
					spring.second_particle.force = plus(spring.second_particle.force, forces.force_second_particle);
				});
				this.particles.forEach((particle)=>{
					particle.update_position(delta_t);
				});
			}
		}
		
		function integrate_midpoint(current_x, current_v, current_a, delta_t){
			return plus(plus(current_x, scalar_multiply(current_v, delta_t)), scalar_multiply(current_a, delta_t * delta_t));
		}
		
		const vertex_shader_source = 
			`// an attribute will receive data from a buffer
			attribute vec4 position;
			
			uniform mat4 mvp_matrix;

			// all shaders have a main function
			void main() {

			  // gl_Position is a special variable a vertex shader 
			  // is responsible for setting
			  gl_Position = mvp_matrix * position;
			}`;
		
		const fragment_shader_source = 
			`// fragment shaders don't have a default precision so we need
			// to pick one. mediump, short for medium precision, is a good default.
			precision mediump float;

			void main() {
			  // gl_FragColor is a special variable a fragment shader
			  // is responsible for setting
			  gl_FragColor = vec4(1, 0, 0.5, 1); // return redish-purple 
			}`;
			
		const canvas = document.getElementById("c");
		const canvas_picking = {
			// set by the mouse event handler, reset/consumed by the render loop
			"pick_request": null,
			"pick_drag_request": null,
			"pick_reset_request": false
		};
		bind_mouse_events_to_canvas(canvas, canvas_picking);
		
		function bind_mouse_events_to_canvas(canvas, canvas_picking){
			canvas.addEventListener("mousedown", (event)=>{
				const bounds = canvas.getBoundingClientRect();
				canvas_picking.pick_request = {"x": event.x - bounds.left, "y": event.y - bounds.top};
			});
			
			canvas.addEventListener("mouseup", (event)=>{
				canvas_picking.pick_reset_request = true;
			});
			
			canvas.addEventListener("mousemove", (event)=>{
				const bounds = canvas.getBoundingClientRect();
				canvas_picking.pick_drag_request = {"x": event.x - bounds.left, "y": event.y - bounds.top};
			});
		}
		
		const gl = canvas.getContext("webgl", {antialias: true});
		if (!gl) {
			alert("No OpenGL!");
		}
		else{
			start_rendering_to_gl_context(canvas, canvas_picking, gl);
		}
		
		function start_rendering_to_gl_context(canvas, canvas_picking, gl){
			const NEAR = 0.1;
			const FAR = 1100;
			
			gl.clearColor(0, 1, 0, 1);
			
			const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertex_shader_source);
			const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragment_shader_source);
			const program = createProgram(gl, vertexShader, fragmentShader);
			
			gl.useProgram(program);
			
			const positionAttributeLocation = gl.getAttribLocation(program, "position");
			gl.enableVertexAttribArray(positionAttributeLocation);
			
			// buffer mvp_matrix
			const mvp_matrix_buffer = gl.createBuffer();
			const mvp_matrix_position = gl.getUniformLocation(program, "mvp_matrix");
			
			const p_matrix = create_perspective_matrix(90.0, canvas.width/canvas.height, NEAR, FAR);
			const v_matrix = create_lookat_matrix(
				[0, 0, 1], 
				[Math.sin(0), 0, 1 - Math.cos(0)], 
				[0, 1, 0]);
			
			const vp_matrix = multiply(v_matrix, p_matrix);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, vp_matrix);
			
			const active_shader = {
				"positionAttributeLocation": positionAttributeLocation,
				"mvp_matrix_position": mvp_matrix_position
			};
			
			const elements_to_render = {
				"particle_system": create_quad_with_particle_corners(),
				"grid_lines": create_bottom_grid_lines(0, 1000, 1/30)
			};
			
			const render_buffers = {}; //to be filled in during rendering
			const frame_query = {
				// When null, no extra routine would be done to enable picking, 
				// when not null, this field is a function that takes two arguments: 
				// 1. an array of triangles in normalized device coordinates, provided by the lower level rendering calls
				// 2. the object corresponding to the aforementioned triangles
				"picking_query": null,
				"picking_query_result": []
			};
			
			window.requestAnimationFrame((timestamp)=>draw(timestamp, timestamp, vp_matrix, active_shader, elements_to_render, render_buffers, frame_query, canvas, canvas_picking));
		}
		
		function draw(timestamp, previous_timestamp, vp_matrix, active_shader, elements_to_render, render_buffers, frame_query, canvas, canvas_picking){
			gl.clear(gl.COLOR_BUFFER_BIT);
			
			const delta_t = Math.min((timestamp - previous_timestamp) * 0.006, 0.6);

			consume_canvas_picking_request(canvas_picking, frame_query, canvas, vp_matrix);

			render_grid(gl, elements_to_render.grid_lines, active_shader.positionAttributeLocation, vp_matrix, active_shader.mvp_matrix_position, render_buffers);
			
			elements_to_render.particle_system.update(delta_t);
			render_particle_system(gl, elements_to_render.particle_system, active_shader.positionAttributeLocation, vp_matrix, active_shader.mvp_matrix_position, render_buffers, frame_query);
			
			frame_query.picking_query = null;
			
			window.requestAnimationFrame((next_timestamp)=>draw(next_timestamp, timestamp, vp_matrix, active_shader, elements_to_render, render_buffers, frame_query, canvas, canvas_picking));
		}
		
		function consume_canvas_picking_request(canvas_picking, frame_query, canvas, vp_matrix){
			if(canvas_picking.pick_reset_request){ // canvas requests clearing all previously picked objects
				canvas_picking.pick_reset_request = false;
				canvas_picking.pick_drag_request = null;
				canvas_picking.pick_request = null;
				frame_query.picking_query_result = [];
			}else if(frame_query.picking_query_result.length>0 
					&& canvas_picking.pick_drag_request!=null ){ // There are previously picked objects, and the canvas requests dragging them
				const picked_scene_element = frame_query.picking_query_result[0];
				if("particle" in picked_scene_element && "world_to_normalized" in picked_scene_element){
					const normalized_to_viewport = invert_mat4(picked_scene_element.world_to_normalized);
					const normalized_mouse_position = normalize_viewport_coordinates(canvas_picking.pick_drag_request.x, canvas_picking.pick_drag_request.y, canvas);
					normalized_mouse_position[2] = picked_scene_element.depth;
					let mouse_in_world = multiply_4x4_4x1(normalized_to_viewport, [...normalized_mouse_position, 1]);
					mouse_in_world = scalar_multiply4(mouse_in_world, 1/mouse_in_world[3]);
					mouse_in_world = deflate_particle_position(mouse_in_world);
					picked_scene_element.particle.position[0] = mouse_in_world[0];
					picked_scene_element.particle.position[1] = mouse_in_world[1];
					picked_scene_element.particle.force = [0,0,0];
				}
				canvas_picking.pick_drag_request;
				
			}
			else if(canvas_picking.pick_request!=null){ // No reset was requested, no items were previously picked, canvas requests a new pick
				frame_query.picking_query_result = [];
				frame_query.picking_query = create_picking_query(canvas_picking.pick_request, frame_query, canvas);
				canvas_picking.pick_request = null;
			}
		}
		
		function invert_mat4(mat4){
			const glmatrix_mat4 = glMatrix.mat4.fromValues(...mat4);
			const glmatrix_mat4_inverted = glMatrix.mat4.create();
			glMatrix.mat4.invert(glmatrix_mat4_inverted, glmatrix_mat4);
			return [...glmatrix_mat4_inverted];
			
		}
		
		function create_picking_query(pick_request, frame_query, canvas){
			return (triangle, picked_item)=>{
				if(triangle_includes_point2d(triangle, normalize_viewport_coordinates(pick_request.x, pick_request.y, canvas))){
					frame_query.picking_query_result.push(picked_item);
				}
			};
		}
		
		// Z will be set as 0
		function normalize_viewport_coordinates(viewport_x, viewport_y, canvas){
			return [
				viewport_x / canvas.width * 2 - 1,
				(canvas.height - viewport_y) / canvas.height * 2 - 1,
				0
			];
		}
		
		function triangle_includes_point2d(triangle, point2d){
			const first_sign = sign(point2d, triangle[0], triangle[1]);
			const second_sign = sign(point2d, triangle[1], triangle[2]);
			const third_sign = sign(point2d, triangle[2], triangle[0]);
			
			const has_negative = (first_sign < 0) || (second_sign < 0) || (third_sign < 0);
			const has_positive = (first_sign > 0) || (second_sign > 0) || (third_sign > 0);
			
			return !(has_negative && has_positive);
		}
		
		function sign(point2d, startpoint, endpoint){
			return (point2d[0] - endpoint[0]) * (startpoint[1] - endpoint[1]) - (startpoint[0] - endpoint[0]) * (point2d[1] - endpoint[1]);
		}
		
		function createShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);  
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				return shader;
			}

			console.log(gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}
		
		function createProgram(gl, vertexShader, fragmentShader) {
			const program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				return program;
			}

			console.log(gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}
		
		function create_perspective_matrix(fov, aspect, near, far){
			const tanHalfFov = Math.tan(fov / 2);
			
			return [
				1/(aspect * tanHalfFov), 0, 0, 0, 
				0, 1/tanHalfFov, 0, 0, 
				0, 0, -(far + near)/(far - near), -1, 
				0, 0, -(2 * far * near) / (far - near), 0
			];
		}
		
		function create_lookat_matrix(eye, center, up){			
			const f = normalize(minus(center, eye));
			const s = normalize(cross(f, up));
			const u = normalize(cross(s, f));
			
			return [
				s[0], u[0], -f[0], 0,
				s[1], u[1], -f[1], 0,
				s[2], u[2], -f[2], 0,
				-dot(s, eye), -dot(u, eye), dot(f, eye), 1
			];
		}
		
		function create_translation_matrix(translation){
			return[
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				translation[0], translation[1], translation[2], 1
			];
		}
		
		function create_rotation_matrix_along_x(angle){
			const cos_angle = Math.cos(angle);
			const sin_angle = Math.sin(angle);
			return[
				1, 0, 0, 0,
				0, cos_angle, sin_angle, 0,
				0, -sin_angle, cos_angle, 0,
				0, 0, 0, 1
			];
		}
		
		function create_scale_matrix(scale_x, scale_y, scale_z){
			return [
				scale_x, 0, 0, 0,
				0, scale_y, 0, 0,
				0, 0, scale_z, 0,
				0, 0, 0, 1
			];
		}
		
		function normalize(vec3){
			const m = magnitude(vec3);
			return [vec3[0] / m, vec3[1] / m, vec3[2] / m];
		}
		
		function magnitude(vec3){
			return Math.sqrt(vec3[0] * vec3[0] + vec3[1] * vec3[1] + vec3[2] * vec3[2]);
		}
		
		function dot(lhs_vec3, rhs_vec3){
			return lhs_vec3[0] * rhs_vec3[0] + lhs_vec3[1] * rhs_vec3[1] + lhs_vec3[2] * rhs_vec3[2];
		}
		
		function minus(lhs_vec3, rhs_vec3){
			return [lhs_vec3[0] - rhs_vec3[0], lhs_vec3[1] - rhs_vec3[1], lhs_vec3[2] - rhs_vec3[2]];
		}
		
		function plus(lhs_vec3, rhs_vec3){
			return [lhs_vec3[0] + rhs_vec3[0], lhs_vec3[1] + rhs_vec3[1], lhs_vec3[2] + rhs_vec3[2]];
		}
		
		function cross(lhs_vec3, rhs_vec3){
			return [ 
				lhs_vec3[1] * rhs_vec3[2] - lhs_vec3[2] * rhs_vec3[1], 
				lhs_vec3[2] * rhs_vec3[0] - lhs_vec3[0] * rhs_vec3[2],
				lhs_vec3[0] * rhs_vec3[1] - lhs_vec3[1] * rhs_vec3[0]]
		}
		
		function multiply(lhs_mat4, rhs_mat4){
			return [
				dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 0), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 1), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 2), col4(rhs_mat4, 3)),
				dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 0)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 1)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 2)), dot4(row4(lhs_mat4, 3), col4(rhs_mat4, 3))
			]
		}
		
		function multiply_4x4_4x1(mat, vec){
			return [
				dot4(col4(mat, 0), vec),
				dot4(col4(mat, 1), vec),
				dot4(col4(mat, 2), vec),
				dot4(col4(mat, 3), vec)
			]
		}
		
		function scalar_multiply(vec3, scalar){
			return [vec3[0]*scalar, vec3[1]*scalar, vec3[2]*scalar]
		}
		
		function scalar_multiply4(vec4, scalar){
			return [...scalar_multiply(vec4, scalar), vec4[3]*scalar]
		}
		
		function row4(mat, row_index){
			return row(mat, row_index, 4);
		}
		
		function row(mat, row_index, stride){
			const offset = stride * row_index;
			return [mat[offset], mat[offset + 1], mat[offset + 2], mat[offset + 3]];
		}
		
		function col4(mat, col_index){
			return col(mat, col_index, 4);
		}
		
		function col(mat, col_index, stride){
			return [mat[col_index], mat[col_index + stride], mat[col_index + stride * 2], mat[col_index + stride * 3]];
		}
		
		function dot4(lhs_vec4, rhs_vec4){
			return dot(lhs_vec4, rhs_vec4) + lhs_vec4[3] * rhs_vec4[3];
		}
		
		function create_bottom_grid_lines(near, far, lines_per_unit){
			const grid_magnitude = far - near;
			const line_amount = Math.ceil(grid_magnitude * lines_per_unit); //amount for both horizontal and vertical
			const line_spacing = grid_magnitude / line_amount;
			let lines = [];
			for(let i=0; i<line_amount+1; ++i){
				const current_horizontal_pos = i * line_spacing;
				lines.push(0); //x1
				lines.push(current_horizontal_pos); //y1
				lines.push(grid_magnitude); //x2
				lines.push(current_horizontal_pos); //y2
			}
			for(let j=0; j<line_amount+1; ++j){
				const current_vertical_pos = j * line_spacing;
				lines.push(current_vertical_pos); //x1
				lines.push(0); //y1
				lines.push(current_vertical_pos); //x2
				lines.push(grid_magnitude); //y2
			}
			return lines;
		}
		
		function render_grid(gl, grid_lines, positionAttributeLocation, vp_matrix, mvp_matrix_position, render_buffers){
			
			if(!("render_grid_mvp_matrix" in render_buffers)){
				const m_matrix = multiply_sequence([
					create_translation_matrix([-500, -500, 0]),
					create_scale_matrix(5, 1, 1),
					create_translation_matrix([0, 0, -180]),
					create_rotation_matrix_along_x(-Math.PI/2),
					create_translation_matrix([0, 0, -500])
				]);
				
				const mvp_matrix = multiply(m_matrix, vp_matrix);
				
				render_buffers.render_grid_mvp_matrix = mvp_matrix;
			}
			
			if(!("render_grid_gl_lines_buffer" in render_buffers)){
				render_buffers.render_grid_gl_lines_buffer = buffer_lines(gl, grid_lines);
			}else{
				gl.bindBuffer(gl.ARRAY_BUFFER, render_buffers.render_grid_gl_lines_buffer);
			}
			
						
			render_lines(
				gl, 
				grid_lines, 
				positionAttributeLocation, 
				render_buffers.render_grid_mvp_matrix, 
				mvp_matrix_position, 
				render_buffers.render_grid_gl_lines_buffer);
		}
		
		// Returns a handle to a buffer, it is guaranteed that buffer is bound to gl.ARRAY_BUFFER when this function is done
		function buffer_lines(gl, lines, buffer_type = gl.STATIC_DRAW){
			const buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), buffer_type);
			return buffer;
		}
		
		// Shader program should already be set up, line_position_buffer should be bound to gl.ARRAY_BUFFER
		function render_lines(gl, lines, positionAttributeLocation, mvp_matrix, mvp_matrix_position, line_position_buffer){
			const size = 2;          // 2 components per iteration
			const type = gl.FLOAT;   // the data is 32bit floats
			const normalize = false; // use the data as is
			const stride = 0;        // 0 = move size * sizeof(type) each iteration
			const buffer_offset = 0; // start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, buffer_offset);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, mvp_matrix);
			
			const primitiveType = gl.LINES;
			const draw_offset = 0;
			gl.drawArrays(primitiveType, draw_offset, lines.length/size);
		}
		
		function multiply_sequence(sequence){
			let result = create_identity_matrix();
			for(let i=0; i<sequence.length; i++){
				result = multiply(result, sequence[i]);
			}
			return result;
		}
		
		function create_identity_matrix(){
			return [
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
			]
		}
		
		function create_quad_with_particle_corners(){
			const bottom_left = new Particle([-1, -1, 0], [0, 0, 0], 5, [0, 0, 0]);
			const bottom_right = new Particle([1, -1, 0], [0, 0, 0], 5, [0, 0, 0]);
			const top_right = new Particle([1, 1, 0], [0, 0, 0], 5, [0, 0, 0]);
			const top_left = new Particle([-1, 1, 0], [0, 0, 0], 5, [0, 0, 0]);
			
			const bottom_spring = new Spring(bottom_left, bottom_right, 4, 1, 2);
			const right_spring = new Spring(bottom_right, top_right, 4, 1, 2);
			const top_spring = new Spring(top_right, top_left, 4, 1, 2);
			const left_spring = new Spring(top_left, bottom_left, 4, 1, 2);
			const diagonal_spring = new Spring(top_left, bottom_right, 4, 1, Math.sqrt(8));
			
			return new ParticleSystem(
				[bottom_left, bottom_right, top_right, top_left], 
				[bottom_spring, right_spring, top_spring, left_spring, diagonal_spring]
			);
		}
		
		//Shader should already be set up and active, particle_position_buffer should be bound to ARRAY_BUFFER
		function render_particle(gl, particle, quad_triangles, positionAttributeLocation, mvp_matrix, mvp_matrix_position, particle_position_buffer){
			const size = 2;          // 2 components per iteration
			const type = gl.FLOAT;   // the data is 32bit floats
			const normalize = false; // use the data as is
			const stride = 0;        // 0 = move size * sizeof(type) each iteration
			const buffer_offset = 0; // start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, buffer_offset);
			
			gl.uniformMatrix4fv(mvp_matrix_position, false, mvp_matrix);
			
			const primitiveType = gl.TRIANGLE_STRIP;
			const draw_offset = 0;
			gl.drawArrays(primitiveType, draw_offset, quad_triangles.length/size);
		}
		
		function render_particle_system(gl, particle_system, positionAttributeLocation, vp_matrix, mvp_matrix_position, render_buffers, frame_query){
			const lines = [];
			particle_system.springs.forEach((spring)=>{
				lines.push(spring.first_particle.position[0]);
				lines.push(spring.first_particle.position[1]);
				lines.push(spring.second_particle.position[0]);
				lines.push(spring.second_particle.position[1]);
			});
			
			const m_matrix = multiply_sequence([
				create_scale_matrix(50, 50, 1),
				create_translation_matrix([0, 30, -180])
			]);
			
			const mvp_matrix = multiply(m_matrix, vp_matrix);
			
			if(!("render_particle_system_lines_buffer" in render_buffers)){
				render_buffers.render_particle_system_lines_buffer = buffer_lines(gl, lines);
			}else{
				gl.bindBuffer(gl.ARRAY_BUFFER, render_buffers.render_particle_system_lines_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);
			}
			
			render_lines(gl, lines, positionAttributeLocation, mvp_matrix, mvp_matrix_position, render_buffers.render_particle_system_lines_buffer);
			
			//Meant to be rendered as a triangle strip
			const quad_triangles = [
				0, 0,
				0, 1, 
				1, 0,
				1, 1
			];
			
			if(!("render_particle_system_particle_buffer" in render_buffers)){
				render_buffers.render_particle_system_particle_buffer = gl.createBuffer();
				
				gl.bindBuffer(gl.ARRAY_BUFFER, render_buffers.render_particle_system_particle_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(quad_triangles), gl.STATIC_DRAW);
			}else{
				gl.bindBuffer(gl.ARRAY_BUFFER, render_buffers.render_particle_system_particle_buffer);
			}
			
			particle_system.particles.forEach((particle, index)=>{
				const m_matrix = multiply_sequence([
					create_translation_matrix([-0.5, -0.5, 0]),
					create_scale_matrix(10, 10, 1),
					create_translation_matrix(inflate_particle_position(particle.position))
				]);
				
				const mvp_matrix = multiply(m_matrix, vp_matrix);
			
				if(frame_query.picking_query!=null){
					provide_particle_triangles_to_picking_query(particle, quad_triangles, m_matrix, vp_matrix, frame_query.picking_query);
				}
			
				render_particle(gl, particle, quad_triangles, positionAttributeLocation, mvp_matrix, mvp_matrix_position, render_buffers.render_particle_system_particle_buffer);
			});
		}
		
		function inflate_particle_position(particle_position){
			return [particle_position[0] * 50, particle_position[1] * 50 + 30, particle_position[2] - 180];
		}
		
		// This should do the exact opposite of apply_particle_position, important for picking and dragging to work
		// Because when picking/dragging, the mouse position has to be transformed into particle position space
		function deflate_particle_position(particle_position){
			return [particle_position[0] / 50, (particle_position[1] - 30) / 50, particle_position[2] + 180];
		}
		
		function provide_particle_triangles_to_picking_query(particle, quad_triangles, m_matrix, vp_matrix, picking_query){
			const grouped_quad_triangles = [];
			for(let i=0; i<quad_triangles.length;i+=2){
				grouped_quad_triangles.push([quad_triangles[i], quad_triangles[i+1]]);
			}
			
			const normalized_quad_triangles = [];
			const mvp_matrix = multiply(m_matrix, vp_matrix);
			
			grouped_quad_triangles.forEach((position)=>{
				let viewport_position = multiply_4x4_4x1(mvp_matrix, [...position, 0, 1]);
				viewport_position = scalar_multiply4(viewport_position, 1/viewport_position[3]);
				normalized_quad_triangles.push(viewport_position.slice(0, 3));
			});
			
			const pick_result_object = {"particle": particle, "world_to_normalized": vp_matrix, "depth": normalized_quad_triangles[0][2]};
			
			picking_query(normalized_quad_triangles.slice(0, 3), pick_result_object);
			picking_query(normalized_quad_triangles.slice(1, 4), pick_result_object);
		}
		
		</script>
	</body>
</html>